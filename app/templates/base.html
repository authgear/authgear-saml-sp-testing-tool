<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>SAML Testing Tool by Authgear</title>

    <link rel="icon" type="image/png" href="{{ url_for('static', filename='authgear-favicon.png') }}">
    <link rel="apple-touch-icon" href="{{ url_for('static', filename='authgear-favicon.png') }}">

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              primary: {
                50: '#eff6ff',
                500: '#3b82f6',
                600: '#2563eb',
                700: '#1d4ed8',
              }
            }
          }
        }
      }
    </script>
  </head>
  <body class="bg-gray-50 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-7xl">
      <div class="flex flex-col md:flex-row gap-8">
        <!-- Left Sidebar - SAML Explanation -->
        <div class="md:w-1/3">
                  <div class="bg-white rounded-lg shadow-lg p-4 md:p-6 sticky top-8">
          <h1 class="text-xl md:text-2xl font-bold text-gray-900 mb-2">SAML Testing Tool</h1>
          <div class="mb-4 md:mb-6">
            <a href="https://www.authgear.com?utm_source=mini-tool&utm_medium=logo&utm_campaign=saml-tool" 
               target="_blank" 
               rel="noopener noreferrer" 
               class="inline-flex items-center text-sm text-gray-600 hover:text-primary-600 transition-colors">
              <span>Presented by</span>
              <img src="{{ url_for('static', filename='authgear-logo.svg') }}" alt="Authgear" class="ml-1 h-4 w-auto">
            </a>
          </div>
          
          <div class="space-y-4 md:space-y-6">
            <div>
              <h3 class="text-base md:text-lg font-semibold text-gray-900 mb-2 md:mb-3">What is this tool?</h3>
              <p class="text-gray-600 text-xs md:text-sm leading-relaxed">
                This is a SAML testing tool acting as a Service Provider (SP) that allows you to configure and test SAML authentication flows with Authgear or any other Identity Provider (IdP).
              </p>
            </div>

            <div>
              <h3 class="text-base md:text-lg font-semibold text-gray-900 mb-2 md:mb-3">How to use it:</h3>
              <ol class="text-gray-600 text-xs md:text-sm space-y-1 md:space-y-2 list-decimal list-inside">
                <li><strong>Configure your IdP settings</strong> - Enter your Authgear or other Identity Provider's details in the form</li>
                <li><strong>Set up your SP</strong> - Configure your Service Provider settings</li>
                <li><strong>Test authentication</strong> - Click "Login" to initiate SAML authentication</li>
                <li><strong>View results</strong> - Check the attributes and user information returned</li>
              </ol>
            </div>

            <div>
              <h3 class="text-base md:text-lg font-semibold text-gray-900 mb-2 md:mb-3">Key Features:</h3>
              <ul class="text-gray-600 text-xs md:text-sm space-y-1 md:space-y-2 list-disc list-inside">
                <li>Test SAML 2.0 authentication flows</li>
                <li>View user attributes and claims</li>
                <li>Configure various SAML bindings</li>
                <li>Test different NameID formats</li>
                <li>Validate SAML responses</li>
              </ul>
            </div>

            <div class="bg-gradient-to-br from-primary-50 to-blue-50 rounded-xl p-6 border border-primary-100 shadow-sm">
              <div class="text-center">
                <h3 class="text-lg font-semibold text-gray-900 mb-3">Get Started with SAML SSO</h3>
                <p class="text-gray-600 text-sm leading-relaxed mb-6">
                  Experience seamless, secure, and scalable identity management with Authgear.
                </p>
                <a href="https://www.authgear.com?utm_source=mini-tool&utm_medium=cta&utm_campaign=saml-tool" 
                   target="_blank" 
                   rel="noopener noreferrer" 
                   class="inline-flex items-center justify-center w-full px-6 py-3 bg-primary-600 text-white text-sm font-medium rounded-lg hover:bg-primary-700 hover:shadow-md transition-all duration-200 transform hover:-translate-y-0.5">
                  Get started for free
                </a>
              </div>
            </div>


          </div>
        </div>
        </div>

        <!-- Right Content Area -->
        <div class="md:w-2/3">
          <div class="bg-white rounded-lg shadow-lg p-8">
            {% block content %}{% endblock %}
          </div>
        </div>
      </div>
    </div>
    
    <style>
      /* Custom radio button styling */
      input[type="radio"]:checked + label .bg-white {
        border-color: #3b82f6;
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
      }
      
      input[type="radio"]:checked + label .bg-blue-100 {
        background-color: #dbeafe;
      }
      
      input[type="radio"]:checked + label .bg-green-100 {
        background-color: #dcfce7;
      }
      
      /* Hover effects */
      label:hover .bg-white {
        border-color: #93c5fd;
      }
    </style>
    
    <script>
      function copyToClipboard(text) {
        navigator.clipboard.writeText(text).then(function() {
          const button = event.target.closest('button');
          const icon = button.querySelector('svg');
          
          // Show "Copied" feedback
          icon.classList.add('text-green-600');
          
          setTimeout(function() {
            icon.classList.remove('text-green-600');
          }, 1000);
        }).catch(function(err) {
          console.error('Could not copy text: ', err);
        });
      }

      function copyToClipboardWithFeedback(text, button) {
        navigator.clipboard.writeText(text).then(function() {
          const copyIcon = button.querySelector('.copy-icon');
          const checkIcon = button.querySelector('.check-icon');
          
          // Hide copy icon and show check icon
          copyIcon.classList.add('hidden');
          checkIcon.classList.remove('hidden');
          
          // Add success animation
          button.classList.add('scale-110');
          
          setTimeout(function() {
            // Show copy icon and hide check icon
            copyIcon.classList.remove('hidden');
            checkIcon.classList.add('hidden');
            
            // Remove animation
            button.classList.remove('scale-110');
          }, 1500);
        }).catch(function(err) {
          console.error('Could not copy text: ', err);
          
          // Show error feedback
          const copyIcon = button.querySelector('.copy-icon');
          copyIcon.classList.add('text-red-600');
          
          setTimeout(function() {
            copyIcon.classList.remove('text-red-600');
          }, 1000);
        });
      }

      function handleMetadataUpload() {
        const fileInput = document.getElementById('metadata_file');
        const file = fileInput.files[0];
        if (!file) {
          return;
        }

        if (!file.name.endsWith('.xml')) {
          showMetadataStatus('error', 'Please select an XML file');
          return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const xmlContent = e.target.result;
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
            
            if (xmlDoc.getElementsByTagName('parsererror').length > 0) {
              showMetadataStatus('error', 'Invalid XML file');
              return;
            }

            const metadata = parseSamlMetadata(xmlDoc);
            if (metadata) {
              fillFormWithMetadata(metadata);
              showMetadataStatus('success', 'Metadata loaded successfully!');
              
              // Show configuration fields after successful upload
              setTimeout(() => {
                const configurationFields = document.getElementById('configuration_fields');
                const setupMethodSelection = document.getElementById('setup_method_selection');
                configurationFields.classList.remove('hidden');
                setupMethodSelection.classList.add('hidden');
              }, 1000);
            } else {
              showMetadataStatus('error', 'Could not parse SAML metadata');
            }
          } catch (error) {
            console.error('Error parsing metadata:', error);
            showMetadataStatus('error', 'Error parsing metadata file');
          }
        };
        
        reader.onerror = function() {
          showMetadataStatus('error', 'Error reading file');
        };
        
        reader.readAsText(file);
      }

      function parseSamlMetadata(xmlDoc) {
        const nsResolver = xmlDoc.createNSResolver(xmlDoc.documentElement);
        
        // Get Entity ID
        const entityId = xmlDoc.documentElement.getAttribute('entityID');
        
        // Get SSO URLs
        const ssoServices = xmlDoc.getElementsByTagNameNS('urn:oasis:names:tc:SAML:2.0:metadata', 'SingleSignOnService');
        let ssoUrl = '';
        let ssoBinding = '';
        
        for (let service of ssoServices) {
          const binding = service.getAttribute('Binding');
          const location = service.getAttribute('Location');
          
          if (binding.includes('HTTP-Redirect')) {
            ssoUrl = location;
            ssoBinding = 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect';
            break;
          } else if (binding.includes('HTTP-POST')) {
            ssoUrl = location;
            ssoBinding = 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST';
          }
        }
        
        // Get SLO URLs
        const sloServices = xmlDoc.getElementsByTagNameNS('urn:oasis:names:tc:SAML:2.0:metadata', 'SingleLogoutService');
        let sloUrl = '';
        
        for (let service of sloServices) {
          const binding = service.getAttribute('Binding');
          const location = service.getAttribute('Location');
          
          if (binding.includes('HTTP-Redirect')) {
            sloUrl = location;
            break;
          } else if (binding.includes('HTTP-POST')) {
            sloUrl = location;
          }
        }
        
        // Get certificate
        const keyDescriptors = xmlDoc.getElementsByTagNameNS('urn:oasis:names:tc:SAML:2.0:metadata', 'KeyDescriptor');
        let certificate = '';
        
        for (let keyDesc of keyDescriptors) {
          const use = keyDesc.getAttribute('use');
          if (!use || use === 'signing') {
            const x509Cert = keyDesc.querySelector('X509Certificate');
            if (x509Cert) {
              certificate = '-----BEGIN CERTIFICATE-----\n' + 
                           x509Cert.textContent.trim() + 
                           '\n-----END CERTIFICATE-----';
              break;
            }
          }
        }
        
        // Get NameID Format
        const nameIdFormats = xmlDoc.getElementsByTagNameNS('urn:oasis:names:tc:SAML:2.0:metadata', 'NameIDFormat');
        let nameIdFormat = '';
        
        if (nameIdFormats.length > 0) {
          nameIdFormat = nameIdFormats[0].textContent.trim();
        }
        
        return {
          entityId: entityId,
          ssoUrl: ssoUrl,
          sloUrl: sloUrl,
          certificate: certificate,
          nameIdFormat: nameIdFormat,
          ssoBinding: ssoBinding
        };
      }

      function fillFormWithMetadata(metadata) {
        if (metadata.entityId) {
          document.getElementById('idp_issuer').value = metadata.entityId;
        }
        if (metadata.ssoUrl) {
          document.getElementById('idp_sso_url').value = metadata.ssoUrl;
        }
        if (metadata.sloUrl) {
          document.getElementById('idp_slo_url').value = metadata.sloUrl;
        }
        if (metadata.certificate) {
          document.getElementById('idp_cert').value = metadata.certificate;
        }
        if (metadata.nameIdFormat) {
          const nameIdSelect = document.getElementById('nameid_format');
          if (nameIdSelect) {
            // Try to find exact match first
            let found = false;
            for (let option of nameIdSelect.options) {
              if (option.value === metadata.nameIdFormat) {
                option.selected = true;
                found = true;
                break;
              }
            }
            // If no exact match, try to find a similar one
            if (!found) {
              for (let option of nameIdSelect.options) {
                if (option.value.includes('unspecified') || metadata.nameIdFormat.includes('unspecified')) {
                  option.selected = true;
                  break;
                }
              }
            }
          }
        }
        if (metadata.ssoBinding) {
          const bindingSelect = document.getElementById('idp_sso_binding');
          if (bindingSelect) {
            for (let option of bindingSelect.options) {
              if (option.value === metadata.ssoBinding) {
                option.selected = true;
                break;
              }
            }
          }
        }
      }

      function showMetadataStatus(type, message) {
        const statusDisplay = document.getElementById('upload_status_display');
        const statusDiv = document.getElementById('metadata_status');
        const successDiv = document.getElementById('metadata_success');
        const errorDiv = document.getElementById('metadata_error');
        const successText = document.getElementById('metadata_success_text');
        const errorText = document.getElementById('metadata_error_text');
        
        statusDisplay.classList.remove('hidden');
        statusDiv.classList.remove('hidden');
        
        if (type === 'success') {
          successDiv.classList.remove('hidden');
          errorDiv.classList.add('hidden');
          successText.textContent = message;
        } else {
          successDiv.classList.add('hidden');
          errorDiv.classList.remove('hidden');
          errorText.textContent = message;
        }
        
        // Hide status after 5 seconds
        setTimeout(() => {
          statusDisplay.classList.add('hidden');
        }, 5000);
      }

      function selectSetupMethod(method) {
        const setupMethodSelection = document.getElementById('setup_method_selection');
        const uploadMetadataSection = document.getElementById('upload_metadata_section');
        const manualSetupSection = document.getElementById('manual_setup_section');
        const configurationFields = document.getElementById('configuration_fields');
        
        // Hide the method selection
        setupMethodSelection.classList.add('hidden');
        
        if (method === 'upload') {
          // Show upload metadata section
          uploadMetadataSection.classList.remove('hidden');
          manualSetupSection.classList.add('hidden');
        } else if (method === 'manual') {
          // Show manual setup section and configuration fields
          manualSetupSection.classList.remove('hidden');
          uploadMetadataSection.classList.add('hidden');
          configurationFields.classList.remove('hidden');
        }
      }

      function showSetupMethodSelection() {
        const setupMethodSelection = document.getElementById('setup_method_selection');
        const uploadMetadataSection = document.getElementById('upload_metadata_section');
        const manualSetupSection = document.getElementById('manual_setup_section');
        const configurationFields = document.getElementById('configuration_fields');
        
        // Show the method selection
        setupMethodSelection.classList.remove('hidden');
        
        // Hide all other sections
        uploadMetadataSection.classList.add('hidden');
        manualSetupSection.classList.add('hidden');
        configurationFields.classList.add('hidden');
      }

      function clearParametersAndShowSelection() {
        // Clear only IdP configuration fields (not SP parameters)
        const idpFields = [
          'idp_issuer',
          'idp_sso_url', 
          'idp_slo_url',
          'idp_cert',
          'nameid_format',
          'idp_sso_binding',
          'acs_binding'
        ];
        
        idpFields.forEach(fieldName => {
          const field = document.getElementById(fieldName);
          if (field) {
            if (field.tagName === 'SELECT') {
              // Reset select elements to first option
              if (field.options.length > 0) {
                field.selectedIndex = 0;
              }
            } else {
              // Clear text inputs and textareas
              field.value = '';
            }
          }
        });
        
        // Clear file input
        const fileInput = document.getElementById('metadata_file');
        if (fileInput) {
          fileInput.value = '';
        }
        
        // Hide upload status
        const uploadStatusDisplay = document.getElementById('upload_status_display');
        if (uploadStatusDisplay) {
          uploadStatusDisplay.classList.add('hidden');
        }
        
        // Store cleared state in session storage
        sessionStorage.setItem('parametersCleared', 'true');
        
        // Show setup method selection
        showSetupMethodSelection();
      }

      // Initialize drag and drop functionality when DOM is loaded
      document.addEventListener('DOMContentLoaded', function() {
        // Check if parameters were cleared and show setup method selection
        if (sessionStorage.getItem('parametersCleared') === 'true') {
          // Clear the flag
          sessionStorage.removeItem('parametersCleared');
          
          // Clear the form fields
          const idpFields = [
            'idp_issuer',
            'idp_sso_url', 
            'idp_slo_url',
            'idp_cert',
            'nameid_format',
            'idp_sso_binding',
            'acs_binding'
          ];
          
          idpFields.forEach(fieldName => {
            const field = document.getElementById(fieldName);
            if (field) {
              if (field.tagName === 'SELECT') {
                if (field.options.length > 0) {
                  field.selectedIndex = 0;
                }
              } else {
                field.value = '';
              }
            }
          });
          
          // Show setup method selection
          showSetupMethodSelection();
        }
        
        const dropZone = document.getElementById('drop_zone');
        if (dropZone) {
          dropZone.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('border-blue-400', 'bg-blue-50');
          });
          
          dropZone.addEventListener('dragleave', function(e) {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('border-blue-400', 'bg-blue-50');
          });
          
          dropZone.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('border-blue-400', 'bg-blue-50');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
              const file = files[0];
              if (file.name.endsWith('.xml')) {
                document.getElementById('metadata_file').files = files;
                handleMetadataUpload();
              } else {
                showMetadataStatus('error', 'Please select an XML file');
              }
            }
          });
        }
      });

      function toggleManualSetup() {
        const content = document.getElementById('manual_setup_content');
        const buttonText = document.getElementById('manual_setup_button_text');
        const icon = document.getElementById('manual_setup_icon');
        
        if (content.classList.contains('hidden')) {
          content.classList.remove('hidden');
          buttonText.textContent = 'Hide';
          icon.classList.add('rotate-180');
        } else {
          content.classList.add('hidden');
          buttonText.textContent = 'Show';
          icon.classList.remove('rotate-180');
        }
      }

    </script>
  </body>
</html>
